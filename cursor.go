package arango

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"

	gr "github.com/starJammer/grestclient"
)

var (
	EOC = errors.New("Cursor has reached the end.")
)

type CursorEndpoint struct {
	client   *gr.Client
	database *Database
}

type Cursor struct {
	cursor cursor
	ce     *CursorEndpoint
}

type cursor struct {
	HasMore   bool              `json:"hasMore"`
	Result    []json.RawMessage `json:"result"`
	Id        string            `json:"id"`
	Count     int               `json:"count"`
	lastError error
}

type PostCursorOptions struct {
	Count     int
	BatchSize int
	Ttl       int
}

//HasMore will return whether or not this cursor still
//has more data to be read. HasMore will return true
//if and only if there is more data, either locally,
//or on the server.
//A call to c.Next(v) SHOULD not result in an error
//when a c.HasMore() call returned true right before.
//If c.HasMore() returns false, a subsequent call to
//c.Next(v) might return either an EOC error OR it might
//return some other error.
func (c *Cursor) HasMore() bool {
	r, err := c.hasMore()
	c.cursor.lastError = err
	return r
}

//hasMore returns a bool and an error.
//The exported HasMore ignores errors and treats
//them as false but other methods use hasMore
//to see what the error is and use it accordingly.
func (c *Cursor) hasMore() (bool, error) {

	if len(c.cursor.Result) > 0 {
		return true, nil
	}

	//we don't have anything left in
	//results BUT we MIGHT have more on the server
	//fetch the server results and if the
	//server returned anything, then we
	//have more!
	if c.cursor.HasMore == true {

		err := c.ce.put(c.cursor.Id, &c.cursor)

		if err != nil {
			return false, err
		}

		if len(c.cursor.Result) > 0 {
			return true, nil
		}
	}

	return false, nil

}

//HasNext is an alias for HasMore
func (c *Cursor) HasNext() bool {
	return c.HasMore()
}

//Next will unmarshal the next item in the cursor
//into v. Next will automatically go to the server
//for more data if there isn't any more left locally.
//If there is no more data, either locally or on
//the server then an EOC (end of cursor) error is returned.
func (c *Cursor) Next(v interface{}) error {

	//return the last error generated by HasMore
	//if there is one.
	if c.cursor.lastError != nil {
		return c.cursor.lastError
	}

	if len(c.cursor.Result) == 0 {
		more, err := c.hasMore()
		if err != nil {
			return err
		}

		if !more {
			return EOC
		}
	}

	err := json.Unmarshal(c.cursor.Result[0], v)
	c.cursor.Result = c.cursor.Result[1:]

	if err != nil {
		return err
	}

	return nil
}

//Count returns the total number of results in the
//cursor. Count should be <= Limit if you use a limit when
//searching.
func (c *Cursor) Count() int {
	return c.cursor.Count
}

//Id returns this cursor's Id. Only cursors that couldn't
//return all the available data in one call will have an
//id that will let them go back to arango and fetch the rest
//of the data.
func (c *Cursor) Id() string {
	return c.cursor.Id
}

func (ce *CursorEndpoint) Post(query string, opts *PostCursorOptions) (*Cursor, error) {

	return nil, nil
}

//Put -> PUT on /_api/simple/by-example
func (ce *CursorEndpoint) Put(cursorIdentifier string) (*Cursor, error) {
	var c cursor
	err := ce.put(cursorIdentifier, &c)
	if err != nil {
		return nil, err
	}
	return &Cursor{cursor: c, ce: ce}, nil
}

func (ce *CursorEndpoint) put(cursorIdentifier string, cursor *cursor) error {

	var errorResult = ArangoError{}

	h, err := ce.client.Put(&gr.Params{
		Path: fmt.Sprintf("/%s", cursorIdentifier),
		UnmarshalMap: gr.UnmarshalMap{
			http.StatusOK:         cursor,
			http.StatusBadRequest: &errorResult,
			http.StatusNotFound:   &errorResult,
		},
	})

	if err != nil {
		return err
	}

	if h.StatusCode != http.StatusOK {
		return errorResult
	}

	return nil
}
